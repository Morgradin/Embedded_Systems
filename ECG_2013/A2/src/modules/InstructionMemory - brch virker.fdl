ipblock instMem(in address : ns(5);
                in wr      : ns(1);
                in rd      : ns(1);  
                in idata   : ns(32);
                out odata  : ns(32)) {

   iptype "ram";
   ipparm "wl=32"; 
   ipparm "size=64";
   ipparm "file=program.txt";  
 }
 


dp PC(in pc_in : ns(19); out pc_out : ns(5); in wr : ns(1)) {

  reg current : ns(5); // Lokalt register
  reg incoming : ns(5);
  sig tmp : ns(5);
  sig pc_short: ns(5);

  always {
    $display("");
    $display("");
    $display("[", $cycle, "]PC -> wr: ", wr, ", incoming: ", incoming, ", pc_out: ", pc_out);

    tmp = wr ? pc_in -1: current + 1;
    pc_out = current = tmp;
  }
}



dp instructionMemory(in address : ns(5);
                     out ctrl   : ns(13);
                     out instVal: ns(19)) { 

    reg adr : ns(5);
    reg iv : ns(19); // Delalying signal to match the rest. Why?

    sig instData: ns(32);
    sig adrc : ns(5);
    
    use instMem(adrc, 0, 1, 0, instData);

    always{
        $display($dec, "[", $cycle, "]instructionMemory - read address: ", adrc, ", instVal: ", iv);//ctrl_out: ", ctrl, ", instVal: ", instVal);
        ctrl = instData[31:19];
        iv = instData[18:0];
        instVal = iv;

        adr = address;
        adrc = adr;
    }
}




dp controller(in ctrl         : ns(13);
              out asel        : ns(3);
              out bsel        : ns(3);
              out storesel    : ns(3); 
              out storeenable : ns(1);
              out alustate    : ns(3);
              out s_mux1      : ns(1);
              out s_mux2      : ns(1);
              out ctrljump    : ns(1)) {


    sfg DISPLAY {
        $display($bin, "[", $cycle, "]Controller - opcode: ", ctrl[12:9], ", ctrl: ", ctrl, ", ctrljump: ", ctrljump);
    }


    sfg LOAD{
        $display("LOAD");
    }
    sfg STRE{
        $display("STORE");
    }
    sfg MOVE{
        $display("MOVE");
        asel = 0;             // Not used in this state
        bsel = ctrl[5:3];
        storesel = ctrl[8:6];
        storeenable = 1;
        alustate = 0;         // Not used in this state
        s_mux1 = 1;
        s_mux2 = 0;
        ctrljump = 0;
        
    }


    sfg ADDI{
        $display("ADDI");
        asel = 0;             // Not used in this state
        bsel = ctrl[5:3];
        storesel = ctrl[8:6];
        storeenable = 1;
        alustate = 0;
        s_mux1 = 0;
        s_mux2 = 1;
        ctrljump = 0;
        
    }
    sfg SUBI{
        $display("SUBI");
        asel = 0;             // Not used in this state
        bsel = ctrl[5:3];
        storesel = ctrl[8:6];
        storeenable = 1;
        alustate = 1;
        s_mux1 = 0;
        s_mux2 = 1;
        ctrljump = 0;
        
    }
    sfg MULI{
        $display("MULI");
        asel = 0;             // Not used in this state
        bsel = ctrl[5:3];
        storesel = ctrl[8:6];
        storeenable = 1;
        alustate = 2;
        s_mux1 = 0;
        s_mux2 = 1;
        ctrljump = 0;
        
    }
    sfg SHWI{
        $display("SHWI");
        asel = 0;             // Not used in this state
        bsel = ctrl[5:3];
        storesel = ctrl[8:6];
        storeenable = 1;
        alustate = 3;
        s_mux1 = 0;
        s_mux2 = 1;
        ctrljump = 0;
        
    }


    sfg BRCH{
        $display("BRCH");
        asel = 0;             // Not used in this state
        bsel = 0;
        storesel = 0;
        storeenable = 0;
        alustate = 0;
        s_mux1 = 0;
        s_mux2 = 0;
        ctrljump = 1;
    }
    sfg BILT{
        $display("BILT");
    }


    sfg ADD{
        $display("ADD");
        asel = ctrl[5:3];
        bsel = ctrl[2:0];
        storesel = ctrl[8:6];
        storeenable = 1;
        alustate = 0;
        s_mux1 = 1;
        s_mux2 = 1;
        //ctrljump = 0;
        
    }
    sfg SUB{
        $display("SUB");
        asel = ctrl[2:0];
        bsel = ctrl[5:3];
        storesel = ctrl[8:6];
        storeenable = 1;
        alustate = 1;
        s_mux1 = 1;
        s_mux2 = 1;
        ctrljump = 0;
        
    }

    sfg IDLE {
        $display("IDLE");
        // Setting default values
        asel = 0;
        bsel = 0;
        storesel = 0;
        storeenable = 0;
        alustate = 0;
        s_mux1 = 0;
        s_mux2 = 0;
        ctrljump = 0;
        
    }
}





fsm fsm_controller(controller) {
    initial run;
    @run if       (ctrl[12:9] == 0b0001) then (LOAD, DISPLAY) -> run;
         else if  (ctrl[12:9] == 0b0010) then (STRE, DISPLAY) -> run;
         else if  (ctrl[12:9] == 0b0011) then (MOVE, DISPLAY) -> run;

         else if  (ctrl[12:9] == 0b1000) then (ADDI, DISPLAY) -> run;
         else if  (ctrl[12:9] == 0b1001) then (SUBI, DISPLAY) -> run;
         else if  (ctrl[12:9] == 0b1010) then (MULI, DISPLAY) -> run;
         else if  (ctrl[12:9] == 0b1011) then (SHWI, DISPLAY) -> run;

         else if  (ctrl[12:9] == 0b0100) then (BRCH, DISPLAY) -> run;
         else if  (ctrl[12:9] == 0b0101) then (BILT, DISPLAY) -> run;

         else if  (ctrl[12:9] == 0b1100) then (ADD, DISPLAY) -> run;
         else if  (ctrl[12:9] == 0b1101) then (SUB, DISPLAY) -> run;

         else (IDLE, DISPLAY) -> run;
}



 





dp register(in asel     : ns(3);
            in bsel     : ns(3);
            in storesel   : ns(3); 
            in storeenable  : ns(1); 
            in storedata  : tc(32); 
            out a       : tc(32);
            out b       : tc(32)) {
  
  reg r1, r2, r3, r4, r5, r6, r7: tc(32);
  

  always {
    $display($dec, "[", $cycle, "]Register - Store Sel: ", storesel, ", StoreData: ", storedata, ", asel: ", asel, ", bsel: ", bsel);
    a = ( asel == 0b000 ) ? 0b000: 
      ( asel == 0b001 ) ? r1:
      ( asel == 0b010 ) ? r2:
      ( asel == 0b011 ) ? r3:
      ( asel == 0b100 ) ? r4:
      ( asel == 0b101 ) ? r5:
      ( asel == 0b110 ) ? r6:
      r7;

    b = ( bsel == 0b000 ) ? 0b000: 
      ( bsel == 0b001 ) ? r1:
      ( bsel == 0b010 ) ? r2:
      ( bsel == 0b011 ) ? r3:
      ( bsel == 0b100 ) ? r4:
      ( bsel == 0b101 ) ? r5:
      ( bsel == 0b110 ) ? r6:
      r7;


    // Handling datastoring
    r1 = ( storesel == 1) ? (storeenable ? storedata: r1) : r1;
    r2 = ( storesel == 2) ? (storeenable ? storedata: r2) : r2;
    r3 = ( storesel == 3) ? (storeenable ? storedata: r3) : r3;
    r4 = ( storesel == 4) ? (storeenable ? storedata: r4) : r4;
    r5 = ( storesel == 5) ? (storeenable ? storedata: r5) : r5;
    r6 = ( storesel == 6) ? (storeenable ? storedata: r6) : r6;
    r7 = ( storesel == 7) ? (storeenable ? storedata: r7) : r7;


  }
}




dp ALU( in A       : tc(32); 
        in B       : tc(32); 
        in cstate  : ns(3); 
        out C      : tc(32)){
        //out alujump: ns(1) ) {

  always{
      //alujump = (A < B);
      C = ( cstate == 0 ) ? A+B: 
          ( cstate == 1 ) ? B-A:
          ( cstate == 2 ) ? A*B:
          ( cstate == 3 ) ? B>>A:
          0;
    
      $display($dec, "[", $cycle, "]ALU - A: ", A, ", B: ", B, ", C: ", C);//, ", jump: ", alujump);
  }
}






dp mux1(in i0      : tc(32); 
        in i1      : tc(32); 
        in select  : ns(1); 
        out o      : tc(32)) {

    always {
        o = select ? i1: i0;
        $display($dec, "[", $cycle, "]MUX - i0: ", i0, ", i1: ", i1, ", o: ", o, ", select: ", select);
    }
}

dp mux2 : mux1


dp sysRAM {
   sig adr   : ns(5);
   sig ctrl  : ns(13);

   // register
   sig asel       : ns(3);
   sig bsel       : ns(3);
   sig storesel   : ns(3); 
   sig storeenable: ns(1); 
   sig storedata  : tc(32); 
   sig rega       : tc(32);
   sig regb       : tc(32);
   sig a          : tc(32);
   sig regData    : tc(32);
   sig ctrljump   : ns(1);

   sig instVal    : tc(19); // Needs signextension

   // ALU
   sig alustate   : ns(3);
   //sig alujump    : ns(1);

   // mux
   sig s_mux1   : ns(1);
   sig s_mux2   : ns(1);


   //       in      out   in
   use PC(instVal, adr, ctrljump);

   //                     in    out
   use instructionMemory(adr, ctrl, instVal);

   //             in,   out   out   out       out          out       out     out      out
   use controller(ctrl, asel, bsel, storesel, storeenable, alustate, s_mux1, s_mux2, ctrljump);

   //      in  in   in        out      
   use ALU(a, regb, alustate, storedata);
   use register(asel, bsel, storesel, storeenable, regData, rega, regb);

   //       in        in    in     out
   use mux1(instVal, rega, s_mux1, a);
   use mux2(regb, storedata, s_mux2, regData);

   
 }
 


system PCsystem{
    sysRAM;
}


